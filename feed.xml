<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Study Notes</title>
    <link href="http://vivek.im/notes/feed.xml" rel="self" />
    <link href="http://vivek.im/notes/" />
    <updated>2013-04-30T18:41:04+05:30</updated>
    <id>http://vivek.im/notes/</id>
    <entry>
        <title type="html"><![CDATA[S1 - Memory, Data and Addressing]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/hw-sw-interface-s1.html"/>
        <published>2013-04-30T00:00:00+05:30</published>
        <updated>2013-04-30T18:41:04+05:30</updated>
        <id>http://vivek.im/notes/notes/hw-sw-interface-s1.html</id>
        <category scheme="http://vivek.im/notes/tag/hwswint/" term="hwswint" label="hwswint" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <div class="section" id="performance">
<h2>Performance</h2>
<p>Performance is not just about CPU clock speed. Data and instructions reside in the memory and they must be fetched to the CPU from memory to operate upon.</p>
<p>CPU&lt;-&gt;Memory bandwidth can bottleneck performance. Two things can be done for this-
- Increase memory bandwidth so that more data can travel at a time. (DDR1 -&gt; DDR2 -&gt; DDR3)
- Move less data into/out of the CPU. This can be achieved by putting a small amount of memory on the CPU itself (which is called cache memory).</p>
</div>
<div class="section" id="binary-representations">
<h2>Binary Representations</h2>
<p>0s and 1s are represented by high and low voltage. It takes a little bit of time while changing the voltage and it is what limits the speed of the computing system. Electronics are designed to only care about the two specific voltages for 0 and 1 and not care about the voltages in between.</p>
</div>
<div class="section" id="representing-information-as-bits-and-bytes">
<h2>Representing information as bits and bytes</h2>
<p>We're going to group our binary digits into groups of eight which are called <strong>bytes</strong>. The range can be-</p>
<p><tt class="docutils literal">00000000</tt><sub>2</sub> - <tt class="docutils literal">11111111</tt><sub>2</sub></p>
<p>In decimal, the above range can be expressed as-</p>
<p><tt class="docutils literal">0</tt><sub>10</sub> - <tt class="docutils literal">255</tt><sub>10</sub></p>
<p>But using binary form to represent data in our programs can get tedious so hexadecimal form is used. Each hexadecimal digit is 4 bit long. A byte can also be represented as two hexadecimal digits. The range can be-</p>
<p><tt class="docutils literal">00</tt><sub>16</sub> - <tt class="docutils literal">FF</tt><sub>16</sub> (which is also same as <tt class="docutils literal">0</tt><sub>10</sub> - <tt class="docutils literal">225</tt><sub>10</sub>)</p>
<p>In C, <tt class="docutils literal">FA1D37B</tt><sub>16</sub> can be represented as <tt class="docutils literal">0xFA1D37B</tt> or <tt class="docutils literal">0xfa1d37b</tt>. This is an 8 digit hexadecimal number, so it is 8 x 4 bit = 32 bits or 4 bytes long number.</p>
</div>
<div class="section" id="byte-oriented-memory-organization">
<h2>Byte Oriented Memory Organization</h2>
<p>Memory is organized in bytes. Basically it is a big long array of bytes. Each byte has an address.</p>
</div>
<div class="section" id="machine-words">
<h2>Machine Words</h2>
<p>Machine has a &quot;word size&quot;.</p>
<p>Until recently, most machines used 32-bit (4-byte) words. It limited address to 4GB and it has become too small for memory intensive applications.</p>
<p>Now, most x86 systems use 64-bit (8-byte) words which has potential address space of 2<sup>64</sup> ~ 1.8 x 10<sup>19</sup> bytes (18EB - exabytes).</p>
<p>For backward compatibility, many CPUs support different word sizes of 16-bit, 8-bit, 4-bit, 2-bit and 1-bit.</p>
</div>
<div class="section" id="word-oriented-memory-organization">
<h2>Word Oriented Memory Organization</h2>
<p>Addresses specify location of bytes in memory and each byte has an address.</p>
<p>In 32-bit systems, 4 bytes have to be grouped together into a word. And 64-bit systems have 8 byte words. So, what address do we give to those word with multiple bytes?</p>
<p>To maintain uniformity, address of a word is said to be the address of its first byte. [Refer to the last slide in <tt class="docutils literal"><span class="pre">lecture_slides_01_012-memorg.pdf</span></tt>]</p>
<p>Pointer is a data object that contains an address.</p>
</div>
<div class="section" id="byte-ordering">
<h2>Byte Ordering</h2>
<p>Say you want to store the 4-byte word <tt class="docutils literal">0xaabbccdd</tt>. In what order will the bytes be stored? There are two different conventions for that.</p>
<p>Big Endian and Little Endian. (Origin: Gulliver's Travels)</p>
<p><strong>Big Endian</strong>: The most significant byte of the number goes the lowest address.</p>
<p><strong>Little Endian</strong>: The least significant byte of the number goes the lowest address.</p>
<p>Example -</p>
<p>Variable has 4-byte representation <tt class="docutils literal">0x01234567</tt> and address of variable is <tt class="docutils literal">0x100</tt>.</p>
<p><strong>Big Endian</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr><td>0x100</td>
<td>0x101</td>
<td>0x102</td>
<td>0x103</td>
</tr>
<tr><td>01</td>
<td>23</td>
<td>45</td>
<td>67</td>
</tr>
</tbody>
</table>
<p><strong>Little Endian</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr><td>0x100</td>
<td>0x101</td>
<td>0x102</td>
<td>0x103</td>
</tr>
<tr><td>67</td>
<td>45</td>
<td>23</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>x86 architecture uses little endian convention.</p>
</div>
<div class="section" id="address-and-pointers-in-c">
<h2>Address and Pointers in C</h2>
<p>Variable declaration: <tt class="docutils literal">int x, y;</tt></p>
<p>The two variables will find two locations in memory in which to store 2 integers (1 word each).</p>
<p>Pointer declaration: <tt class="docutils literal">int *ptr;</tt></p>
<p>Declares aa variable <tt class="docutils literal">ptr</tt> that is a pointer to a data item that in an integer. This will store an address rather than a value.</p>
<p>Assignment to a pointer: <tt class="docutils literal">ptr = &amp;x;</tt></p>
<p>This assigns ptr to point to the address where x is located. <tt class="docutils literal">&amp;</tt> is used to get the address of a variable.</p>
<p>Get value pointed to by a pointer:</p>
<p>Dereference operator (<tt class="docutils literal">*</tt>) is used to get the value pointed to by a pointer. <tt class="docutils literal">*ptr</tt> will give us the value at the memory address given by the value of <tt class="docutils literal">ptr</tt>.</p>
<p>Examples</p>
<ul class="simple">
<li>If <tt class="docutils literal">ptr = &amp;x;</tt> then <tt class="docutils literal">y = *ptr + 1</tt> is same as <tt class="docutils literal">y = x + 1</tt>.</li>
<li><tt class="docutils literal"><span class="pre">*(&amp;y)</span></tt> is equivalent to <tt class="docutils literal">y</tt>.</li>
</ul>
<p>We can do arithmetic on pointers.</p>
<p><tt class="docutils literal">ptr = ptr + 1</tt> - Since type of ptr is int and an int uses 4 bytes, C automatically adds (1 x 4 =) 4. But this can be dangerous if we don't exactly know what is present at the next memory address.</p>
</div>
<div class="section" id="assignment-in-c">
<h2>Assignment in C</h2>
<p>Left-Hand-Side = Right-Hand-Side</p>
<p>LHS must evaluate to a memory location (variable).</p>
<p>RHS must evaluate to a value (could be an address).</p>
<p><tt class="docutils literal">int x, y; x = y + 3;</tt> - Get value at y, add 3, put it in x</p>
<p><tt class="docutils literal">int *x; int y; x = &amp;y + 3;</tt> - Get address of y, add (3 x 4 =) 12 to it, put it in x</p>
<p><tt class="docutils literal">*x = y;</tt> - Here <tt class="docutils literal">*</tt> says to the compiler not to use <tt class="docutils literal">x</tt> itself as the variable rather get the value stored at x, interpret it as an address, put value of y at that address.</p>
</div>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[JavaScript Basics]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/javascript-basics.html"/>
        <published>2013-03-27T00:00:00+05:30</published>
        <updated>2013-04-03T05:48:41+05:30</updated>
        <id>http://vivek.im/notes/notes/javascript-basics.html</id>
        <category scheme="http://vivek.im/notes/tag/javascript/" term="javascript" label="javascript" />
        <category scheme="http://vivek.im/notes/tag/basics/" term="basics" label="basics" />
        <category scheme="http://vivek.im/notes/tag/notes/" term="notes" label="notes" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <p>The core language features of JavaScript are defined in ECMA-262 as a pseudolanguage named ECMAScript. ECMAScript contains all of the basic syntax, operators, data types, and objects necessary to complete basic computing tasks, though it provides no way to get input or to produce output. Understanding ECMAScript and its intricacies is vital to a complete understanding of JavaScript as implemented in web browsers.</p>
<p><strong>Data types</strong></p>

<ul>
<li>undefined - for undefined variables</li>
<li>null - empty object pointer</li>
<li>boolean - true or false</li>
<li>string</li>
<li>number</li>
<li>object</li>
<li>function</li>
</ul>
<p>Variable initiliazation</p>

<pre><code>::js
var abc = &quot;lola&quot;; // creates local variable
xyz = &quot;loli;&quot; // creates global variable (bad)</code></pre>
<p>Type checking</p>

<pre><code>::js
typeof any_uninitialized_variable; // undefined

var spam;
typeof undefined; // undefined</code></pre>
<p>undefined is unpredictable. You won&#39;t know if the variable has been just initialized or it hasn&#39;t.</p>

<ul>
<li>Don&#39;t set value of any variable to undefined explicitly.</li>
<li>Any time an object is expected but is not available, null should be used in its place.</li>
</ul>
<p>Because storing floating-point values uses twice as much memory as storing integer values, ECMAScript always looks for ways to convert values into integers.</p>

<pre><code>::js
var someNum = 22.0; // interpreted as integer 22</code></pre>
<p>There is a special numeric value called <strong>NaN</strong>, short for Not a Number, which is used to indicate when an operation intended to return a number has failed (as opposed to throwing an error).</p>

<ul>
<li>Dividing a number by 0 gives NaN.</li>
<li>Any operation involving NaN returns NaN.</li>
</ul>
<p>NaN&#39;s peculiar behavior.</p>

<pre><code>::js
NaN == NaN; // returns false</code></pre>
<p>Use isNaN(); function to check for NaN.</p>

<pre><code>::js
isNaN(&quot;11&quot;); // false - can be converted to 11
isNaN(&quot;lola&quot;); // true - cannot be converted to a number
isNaN(true); // false - can be converted to 1</code></pre>
<p><strong>Numbers</strong></p>

<pre><code>::js
Number(&quot;100 Cats&quot;); // NaN
Number(&quot;100&quot;); // 100
Number(&quot;&quot;); // 0
Number(true); // 1
Number(&quot;000010&quot;); // 10 (leading 0s are ignored)</code></pre>
<p>Because of the complexities and oddities of the Number() function when converting strings, the parseInt() function is usually a better option when you are dealing with integers.</p>

<pre><code>::js
parseInt(&quot;100 Cats 323&quot;); // 100
parseInt(&quot;Cats 100 203&quot;); // NaN</code></pre>
<p>If this first character isn’t a number, the minus sign, or the plus sign, parseInt() always returns NaN, which means the empty string returns NaN (unlike with Number(), which returns 0).</p>
<p>Radix can be passed as second argument to parseInt(). It is a good idea to pass the value (10 for decimals, 2 for binary, 8 for octal and 16 for hexadecimal) to avoid any errors.</p>
<p><strong>Strings</strong></p>
<p>Strings are immutable in ECMAScript like in Python. To change the string value held by a variable, it must be destroyed and replaced with the new one.</p>
<p>A value can be converted to string easily by adding &ldquo;&rdquo; to it.</p>

<pre><code>::js
9 + &quot;&quot;; // &quot;9&quot;</code></pre>
<p><strong>Boolean</strong></p>
<p>Logical NOT can be performed with ! sign before the value.</p>
<p>Logical AND: &amp;&amp;</p>
<p>Logical OR: ||</p>

<pre><code>::js
null == undefined; //true
&quot;NaN&quot; == NaN; //false
5 == NaN; //false
NaN == NaN; //false
NaN =! NaN; //true
false == 0; //true
true == 1; //true
true == 2; //false
undefined == 0; //false
null == 0; //false
&quot;5&quot; == 5; //true
&quot;5&quot; === 5; //false</code></pre>
<p>=== does comparison without type conversion.</p>
<p><strong>Conditional Operator</strong></p>

<pre><code>::js
variable = boolean_expression ? true_value : false_value;
var max = (num1 &gt; num2) ? num1 : num2;</code></pre>
<p><strong>if Statement</strong></p>

<pre><code>::js
if (condition) {
    statement1;
} else if {
     statement2;
} else {
     statement3;
}</code></pre>
<p><strong>do Statement</strong></p>

<pre><code>::js
do {
    statement;
} while (expression);</code></pre>
<p><strong>while Statement</strong></p>

<pre><code>::js
while (expression) {
    statement;
}</code></pre>
<p><strong>for Statement</strong></p>
<p>Nothing can be done with a for loop that can’t be done using a while loop. The for loop simply encapsulates the loop-related code into a single location.</p>

<pre><code>::js
for (initialization; expression; post-loop-expression) {
    statement;
}

for (var i=0; i&lt;=5; i++) {
    alert(i);
}</code></pre>
<p><strong>for-in Statement</strong></p>

<pre><code>::js
for (property in expression) {
    statement;
}</code></pre>
<p><strong>Labeled Statement</strong></p>
<p>Statements can be labeled using following syntax. Mostly used in loops to break out the outer loop.</p>

<pre><code>::js
label: statement;</code></pre>
<p><strong>with Statement</strong></p>
<p>The with statement sets the scope of the code within a particular object.</p>

<pre><code>::js
with (expression) {
    statement;
}</code></pre>
<p>Example:</p>

<pre><code>::js
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;</code></pre>
<p>can be rewritten as:</p>

<pre><code>::js
var qs = search.substring(1);
var hostName = hostname;
var url = href;</code></pre>
<p>Note: It is widely considered a poor practice to use the with statement in production code because of its negative performance impact and the difficulty in debugging code contained in the with statement.</p>
<p><strong>switch Statement</strong></p>

<pre><code>::js
switch (expression) {
    case value/expression: statement;
    break;
    case value/expression: statement;
    break;
    default: statement;
}</code></pre>
<p>Each case in a switch statement says, “If the expression is equal to the value, execute the statement.” The break keyword causes code execution to jump out of the switch statement. Without the break keyword, code execution falls through the original case into the following one.</p>

<h2 id="toc_0">Functions</h2>

<pre><code>::js
function functionName(arg1, arg2,…, argN) {
    statements
}</code></pre>
<p>Function arguments in ECMAScript don’t behave in the same way as function arguments in most other languages. <strong>An ECMAScript function doesn’t care how many arguments are passed in</strong>, nor does it care about the data types of those arguments. Just because you define a function to accept two arguments doesn’t mean you can pass in only two arguments. You could pass in one or three or none, and the interpreter won’t complain. This happens because arguments in ECMAScript are represented as an array internally.</p>
<p>There is an arguments object that can be accessed inside a function which contains all the passed in arguments. Individual arguments can be accessed by using index notation.</p>
<p>All arguments in ECMAScript are passed by value. It is not possible to pass arguments by reference.</p>
<p>Functions that don&#39;t return any value explicitly actually return undefined.</p>
<p><strong>Primitive and Reference Values</strong></p>
<p>ECMAScript variables may contain two different types of data: primitive values and reference values.</p>
<p><strong>Primitive Values</strong> - Simple atomic pieces of data. These are accessed by value. These are undefined, null, number, string and boolean.</p>
<p><strong>Reference Values</strong> - Objects that may be made up of multiple values. JavaScript does not permit direct access of memory locations, so direct manipulation of the object’s memory space is not allowed. When you manipulate an object, <strong>you’re really working on a reference to that object rather than the actual object itself</strong>. For this reason, such values are said to be accessed by reference.</p>

<ul>
<li>When copying primitive values, stored value in one variable is hard copied to the other variable. They then have nothing to do with each other.</li>
<li>Whereas when copying reference values, pointer from one variable is simply copied to the other variable, both of which point to the same object stored on the heap. Changes made to the object with access from any of the variable affects all the other ones.</li>
</ul>
<p>Now, let&#39;s focus on argument passing. All function arguments in ECMAScript are passed by values. This means that the value outside of the function is copied into an argument on the inside of the function the same way a value is copied from one variable to another.</p>
<p>When the argument is passed by value, the value is copied into a local variable (a named argument is available and in arguments object). This happens in accordance to the rules mentioned above.</p>
<p>In case of reference values when passed in arguments, a local copy of the pointer is made but they both still point to the same object. Changes made to the object inside the function will reflect even outside of it.</p>
<p>It can be checked whether the variable contains primitive or reference value by using isinstanceof operator with following syntax.</p>

<pre><code>::js
result = variable isinstanceof constructor;

person isinstanceof Object;
colors isinstanceof Array;</code></pre>
<p>All reference values, by definition, are instances of Object, so the instanceof operator always returns true when used with a reference value and the Object constructor. Similarly, if instanceof is used with a primitive value, it will always return false, because primitives aren’t objects.</p>
<p><strong>Execution Context and Scope</strong></p>
<p>There are mainly two execution context (or scope) which are at global and function level. Also the with statement and the catch block in try-catch statement have their own execution context.</p>
<p>If var is omitted while initializing a variable inside of a function, it is created in global context.</p>

<h2 id="toc_1">Reference Types</h2>
<p>A reference value (object) is an instance of a specific reference type. In ECMAScript, reference types are structures used to group data and functionality together and are often incorrectly called classes.</p>
<p><strong>Object Type</strong></p>
<p>Can be created in two ways:</p>

<pre><code>::js
var person = new Object();
person.name = &quot;lola&quot;;

//or

var person = {
    name: &quot;lola&quot;;
}</code></pre>
<p>Object properties can be accessed using dot notation as well as using bracket notation.</p>

<pre><code>::js
person.name;
person[&quot;name&quot;]; // both are same</code></pre>
<p><strong>Array Type</strong></p>
<p>ECMAScript arrays are dynamically sized. A same array can hold any data type in each slot. Can be created in following ways:</p>

<pre><code>::js
var colors = new Array(&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;);
var colos = Array(&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;);
var colors = [&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;];</code></pre>
<p>Elements can be accessed using bracket notation. Arrays have length property with which the size of an array can be known. By setting the length property, you can easily remove items from or add items to the end of the array.</p>
<p><strong>Array Methods</strong></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Scala Basics]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/scala-basics.html"/>
        <published>2013-03-27T00:00:00+05:30</published>
        <updated>2013-04-03T05:55:37+05:30</updated>
        <id>http://vivek.im/notes/notes/scala-basics.html</id>
        <category scheme="http://vivek.im/notes/tag/scala/" term="scala" label="scala" />
        <category scheme="http://vivek.im/notes/tag/basics/" term="basics" label="basics" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <p>Imperative Programming is about</p>

<ul>
<li>modifying mutable variables,</li>
<li>using assignments</li>
<li>and control structures such as if-then-else, loops, breaks, continue, return.</li>
</ul>
<p>Pure imperative programming is limited by the “Von Neumann” bottleneck:</p>

<blockquote>
<p>One tends to conceptualize data structures word-by-word.</p>
</blockquote>
<p>We need other techniques for deﬁning high-level abstractions such as collections, polynomials, geometric shapes, strings, documents.</p>
<p>A theory consists of one or more data types, operation on these data types and laws that describe the relationship between values and operations.</p>
<p>Normally, a theory doesn&#39;t describes mutations!</p>
<p>Functional Programming is about</p>

<ul>
<li>In a restricted sense, it means programming without mutable variables, assignments, loops and other imperative control stuctures.</li>
<li>In a wider sense, functional programming means focusing on the functions to construct elegant programs.</li>
<li>In particular, functions can be values that are produced, consumed and composed.</li>
<li>Functions are first class citizens. They can be defined anywhere, including inside other functions.</li>
<li>Functions like any other value, passed as parameter to functions and returned as results. As for other values, there exists a set operators to compose
functions.</li>
</ul>
<p>Functional Programming is becoming increasingly popular because it oﬀers an attractive method for exploiting parallelism for multicore and cloud computing.</p>
<p>In a parallel environment, when multiple threads try to access and mutate a shared mutable state, problems arises. Though there are ways to solve it, it is not always easy and elegant as desired. In functional programming, by eliminating the use of mutable states these problems can be easily solved.</p>
<p>Functions can be defined as:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="k">def</span> <span class="n">sumOfSquares</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">square</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>

<span class="cm">/* Here, the return type is defined as well. */</span>
<span class="k">def</span> <span class="n">power</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
<p><strong>Call by value (CBV)</strong> - All the arguments are evaluated to a simple value and then passed on to the function body as soon as the function is ran.</p>
<p>Example:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">example</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">example</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm">Evaluated as-</span>
<span class="cm">example(2+3, 7) -&gt; example(5, 7) -&gt; 5 * 5 -&gt; 25</span>
<span class="cm">*/</span>
</pre></div>
<p><strong>Call by name (CBN)</strong> - All the arguments are passed to the function body as it is and evaluation is done by the code within the function body.</p>
<p>Example:</p>
<div class="highlight"><pre><span class="n">example</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm"> * Evaluated as-</span>
<span class="cm"> * example(2+3, 7) -&gt; (2+3) * (2+3) -&gt; 5 * (2+3) -&gt; 5 * 5 -&gt; 25</span>
<span class="cm"> */</span>
</pre></div>
<p>If CBV evaluation of an expression <em>e</em> terminates, then CBN evaluation of <em>e</em> terminates too.</p>
<p>The other direction is not true.</p>
<p>Non-termination example</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">first</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>

<span class="n">first</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">loop</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm"> * Here, the loop resolves to itself infinitely.</span>
<span class="cm"> * </span>
<span class="cm"> * Under CBN:</span>
<span class="cm"> * first(1, loop) -&gt; 1</span>
<span class="cm"> * </span>
<span class="cm"> * Under CBV:</span>
<span class="cm"> * first(1, loop) -&gt; first(1, loop) -&gt; first(1, loop)....</span>
<span class="cm"> */</span>
</pre></div>
<p>Scala normally uses call-by-value.</p>
<p>But if the type of a function parameter starts with =&gt;, it uses call-by-name.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">consOne</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>

<span class="cm">/* Here, x is evaluated as CBV by default and y is evaluated as CBN which we explicitly forced it to. */</span>
</pre></div>
<p><strong>Conditional Expressions</strong></p>
<p>if-else in Scala is used for expressions, not statements.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span>
</pre></div>
<p>Rewrite rules for Booleans (e is an arbitrary expression):</p>
<div class="highlight"><pre><span class="cm">/* !true        --&gt; false</span>
<span class="cm"> * !false       --&gt; true</span>
<span class="cm"> * true &amp;&amp; e    --&gt; e</span>
<span class="cm"> * false &amp;&amp; e   --&gt; false</span>
<span class="cm"> * true || e    --&gt; true</span>
<span class="cm"> * false || e   --&gt; e</span>
<span class="cm"> */</span>
</pre></div>
<p><strong>Value Definitions</strong></p>
<p>The <code>def</code> form is &ldquo;by name&rdquo;, its right hand side evaluated on each use.</p>
<p>There is also a <code>val</code> for, which is &ldquo;by value&rdquo;. Example-</p>
<div class="highlight"><pre><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div>
<p>The right hand side of a val definition is evaluated at the point of the definition itself.</p>
<p>Afterwards the name refers to the value. Here y refers to 4, not square(2).</p>
<p><strong>Difference between val and def</strong></p>
<p>The difference becomes apparent when the right hand side does not terminate.</p>
<div class="highlight"><pre><span class="cm">/* This works fine. */</span>
<span class="k">def</span> <span class="n">loop</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">loop</span>
<span class="k">def</span> <span class="n">x</span> <span class="k">=</span> <span class="n">loop</span>

<span class="cm">/* However, this will get stuck in an infinite loop since the interpreter tries to evaluate the loop right at the point of definition. */</span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">loop</span>
</pre></div>
<p>&amp;&amp; and || implementation as functions-</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">and</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">false</span>
<span class="k">def</span> <span class="n">or</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(!</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">true</span>
</pre></div>
<p><strong>Return type is required when calling a function recursively.</strong></p>
<p><strong>Blocks in Scala</strong></p>
<p>A block is defined by curly braces {&hellip;.}.</p>
<div class="highlight"><pre><span class="o">{</span>
    <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span>
</pre></div>
<p>It constains a sequence of definition or expressions.
The last element of a block is an expression that deﬁnes its value.
This return expression can be preceded by auxiliary deﬁnitions.
Blocks are themselves expressions; a block may appear everywhere an expression can.</p>

<ul>
<li>The deﬁnitions inside a block are only visible from within the block.</li>
<li>The deﬁnitions inside a block shadow deﬁnitions of the same names outside the block.</li>
</ul>
<p><strong>Semicolons</strong></p>
<p>In Scala, semicolons at the end of a line is optional in most cases. If there are more than one statements in one line, then they need to be separatd with a semi-colon.</p>
<p><strong>Semicolons and inﬁx operators</strong></p>
<p>One issue with Scala’s semicolon convention is how to write expressions that span several lines. For instance-</p>
<div class="highlight"><pre><span class="n">someLongExpression</span>
<span class="o">+</span> <span class="n">someOtherExpression</span>

<span class="cm">/* would be interpreted as */</span>

<span class="n">someLongExpression</span><span class="o">;</span>
<span class="o">+</span> <span class="n">someOtherExpression</span>
</pre></div>
<p>Two ways to overcome the problem.</p>
<div class="highlight"><pre><span class="cm">/* Multiline expression can be written inside parentheses. */</span>
<span class="o">(</span><span class="n">someLongExpression</span>
    <span class="o">+</span> <span class="n">someOtherExpression</span><span class="o">)</span>

<span class="cm">/* Or operator can be written on the first line because this tells the Scala compiler that the expression is not yet finished. */</span>
<span class="n">someLongExpression</span> <span class="o">+</span>
<span class="n">someOtherExpression</span>
</pre></div>
<p><strong>Tail Recursion</strong></p>
<p>If a function calls itself as its last action, the function&#39;s stack frame can be reused. This is called tail recursion. Tail recursive functions are iterative processes.</p>
<p>In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be suﬃcient for both functions. Such calls are called tail-calls.</p>
<p>Example of non-tail recursive factorial function:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
<p>Example of tail recursive factorial function:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> 
    <span class="k">def</span> <span class="n">fac_loop</span><span class="o">(</span><span class="n">accum</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">accum</span>
        <span class="k">else</span> <span class="n">fac_loop</span><span class="o">(</span><span class="n">accum</span> <span class="o">*</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">loop</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
<p>In the first example, the return value <code>x * factorial(x-1)</code> has a pending calculation of x multiplied by factorial of (x-1) which would have to wait until that factorial has been computed and thus that recursive chain keeps on growing.</p>
<p>However, in the second example, for the return value <code>fac_loop(accum * n, n - 1)</code> the function calls itself and there are no pending computation to be done, so the further function calls can take place in the same stack frame without growing like crazy like in the previous example.</p>
]]>
        </content>
    </entry>
</feed>