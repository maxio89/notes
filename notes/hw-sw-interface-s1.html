<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>S1 - Memory, Data and Addressing - Study Notes</title>
        <script>if (top !== self) top.location = self.location;</script>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0" />
        <link rel="stylesheet" href="/static/style.css?v=af9b9" />
        <link rel="stylesheet" href="/static/pygments.css?v=c6adc" />
        
        <link rel="alternate" type="application/rss+xml" href="/feed.xml" title="Study Notes" />
        <!--[if lt IE 9]>
        <script type="text/javascript" src="/static/html5shiv.js?v=9a10c"></script>
        <![endif]-->
        
        
<link rel="canonical" href="/notes/hw-sw-interface-s1.html" />


    </head>
    <body>
        <header id="header">
            <h1 id="brand"><a href="/">Study Notes</a></h1>
            <nav id="nav" role="navigation">
                
                <a href="/"></a>
                <a href="/about.html"></a>
            </nav>
        </header>

        <div id="main">
            <div class="container"><div class="hentry">
    <h1 class="entry-title">S1 - Memory, Data and Addressing</h1>
    <div class="entry-meta">
        <time class="updated" datetime="2013-04-30T00:00:00+05:30" pubdate>
            <a href="/2013/">2013-04-30</a>
        </time>
        <span class="author vcard">
            by <span class="fn">Vivek Agarwal</span>
        </span>
    </div>
    <div class="entry-content">
        <div class="section" id="performance">
<h2>Performance</h2>
<p>Performance is not just about CPU clock speed. Data and instructions reside in the memory and they must be fetched to the CPU from memory to operate upon.</p>
<p>CPU&lt;-&gt;Memory bandwidth can bottleneck performance. Two things can be done for this-
- Increase memory bandwidth so that more data can travel at a time. (DDR1 -&gt; DDR2 -&gt; DDR3)
- Move less data into/out of the CPU. This can be achieved by putting a small amount of memory on the CPU itself (which is called cache memory).</p>
</div>
<div class="section" id="binary-representations">
<h2>Binary Representations</h2>
<p>0s and 1s are represented by high and low voltage. It takes a little bit of time while changing the voltage and it is what limits the speed of the computing system. Electronics are designed to only care about the two specific voltages for 0 and 1 and not care about the voltages in between.</p>
</div>
<div class="section" id="representing-information-as-bits-and-bytes">
<h2>Representing information as bits and bytes</h2>
<p>We're going to group our binary digits into groups of eight which are called <strong>bytes</strong>. The range can be-</p>
<p><tt class="docutils literal">00000000</tt><sub>2</sub> - <tt class="docutils literal">11111111</tt><sub>2</sub></p>
<p>In decimal, the above range can be expressed as-</p>
<p><tt class="docutils literal">0</tt><sub>10</sub> - <tt class="docutils literal">255</tt><sub>10</sub></p>
<p>But using binary form to represent data in our programs can get tedious so hexadecimal form is used. Each hexadecimal digit is 4 bit long. A byte can also be represented as two hexadecimal digits. The range can be-</p>
<p><tt class="docutils literal">00</tt><sub>16</sub> - <tt class="docutils literal">FF</tt><sub>16</sub> (which is also same as <tt class="docutils literal">0</tt><sub>10</sub> - <tt class="docutils literal">225</tt><sub>10</sub>)</p>
<p>In C, <tt class="docutils literal">FA1D37B</tt><sub>16</sub> can be represented as <tt class="docutils literal">0xFA1D37B</tt> or <tt class="docutils literal">0xfa1d37b</tt>. This is an 8 digit hexadecimal number, so it is 8 x 4 bit = 32 bits or 4 bytes long number.</p>
</div>
<div class="section" id="byte-oriented-memory-organization">
<h2>Byte Oriented Memory Organization</h2>
<p>Memory is organized in bytes. Basically it is a big long array of bytes. Each byte has an address.</p>
</div>
<div class="section" id="machine-words">
<h2>Machine Words</h2>
<p>Machine has a &quot;word size&quot;.</p>
<p>Until recently, most machines used 32-bit (4-byte) words. It limited address to 4GB and it has become too small for memory intensive applications.</p>
<p>Now, most x86 systems use 64-bit (8-byte) words which has potential address space of 2<sup>64</sup> ~ 1.8 x 10<sup>19</sup> bytes (18EB - exabytes).</p>
<p>For backward compatibility, many CPUs support different word sizes of 16-bit, 8-bit, 4-bit, 2-bit and 1-bit.</p>
</div>
<div class="section" id="word-oriented-memory-organization">
<h2>Word Oriented Memory Organization</h2>
<p>Addresses specify location of bytes in memory and each byte has an address.</p>
<p>In 32-bit systems, 4 bytes have to be grouped together into a word. And 64-bit systems have 8 byte words. So, what address do we give to those word with multiple bytes?</p>
<p>To maintain uniformity, address of a word is said to be the address of its first byte. [Refer to the last slide in <tt class="docutils literal"><span class="pre">lecture_slides_01_012-memorg.pdf</span></tt>]</p>
<p>Pointer is a data object that contains an address.</p>
</div>
<div class="section" id="byte-ordering">
<h2>Byte Ordering</h2>
<p>Say you want to store the 4-byte word <tt class="docutils literal">0xaabbccdd</tt>. In what order will the bytes be stored? There are two different conventions for that.</p>
<p>Big Endian and Little Endian. (Origin: Gulliver's Travels)</p>
<p><strong>Big Endian</strong>: The most significant byte of the number goes the lowest address.</p>
<p><strong>Little Endian</strong>: The least significant byte of the number goes the lowest address.</p>
<p>Example -</p>
<p>Variable has 4-byte representation <tt class="docutils literal">0x01234567</tt> and address of variable is <tt class="docutils literal">0x100</tt>.</p>
<p><strong>Big Endian</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr><td>0x100</td>
<td>0x101</td>
<td>0x102</td>
<td>0x103</td>
</tr>
<tr><td>01</td>
<td>23</td>
<td>45</td>
<td>67</td>
</tr>
</tbody>
</table>
<p><strong>Little Endian</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr><td>0x100</td>
<td>0x101</td>
<td>0x102</td>
<td>0x103</td>
</tr>
<tr><td>67</td>
<td>45</td>
<td>23</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>x86 architecture uses little endian convention.</p>
</div>
<div class="section" id="address-and-pointers-in-c">
<h2>Address and Pointers in C</h2>
<p>Variable declaration: <tt class="docutils literal">int x, y;</tt></p>
<p>The two variables will find two locations in memory in which to store 2 integers (1 word each).</p>
<p>Pointer declaration: <tt class="docutils literal">int *ptr;</tt></p>
<p>Declares aa variable <tt class="docutils literal">ptr</tt> that is a pointer to a data item that in an integer. This will store an address rather than a value.</p>
<p>Assignment to a pointer: <tt class="docutils literal">ptr = &amp;x;</tt></p>
<p>This assigns ptr to point to the address where x is located. <tt class="docutils literal">&amp;</tt> is used to get the address of a variable.</p>
<p>Get value pointed to by a pointer:</p>
<p>Dereference operator (<tt class="docutils literal">*</tt>) is used to get the value pointed to by a pointer. <tt class="docutils literal">*ptr</tt> will give us the value at the memory address given by the value of <tt class="docutils literal">ptr</tt>.</p>
<p>Examples</p>
<ul class="simple">
<li>If <tt class="docutils literal">ptr = &amp;x;</tt> then <tt class="docutils literal">y = *ptr + 1</tt> is same as <tt class="docutils literal">y = x + 1</tt>.</li>
<li><tt class="docutils literal"><span class="pre">*(&amp;y)</span></tt> is equivalent to <tt class="docutils literal">y</tt>.</li>
</ul>
<p>We can do arithmetic on pointers.</p>
<p><tt class="docutils literal">ptr = ptr + 1</tt> - Since type of ptr is int and an int uses 4 bytes, C automatically adds (1 x 4 =) 4. But this can be dangerous if we don't exactly know what is present at the next memory address.</p>
</div>
<div class="section" id="assignment-in-c">
<h2>Assignment in C</h2>
<p>Left-Hand-Side = Right-Hand-Side</p>
<p>LHS must evaluate to a memory location (variable).</p>
<p>RHS must evaluate to a value (could be an address).</p>
<p><tt class="docutils literal">int x, y; x = y + 3;</tt> - Get value at y, add 3, put it in x</p>
<p><tt class="docutils literal">int *x; int y; x = &amp;y + 3;</tt> - Get address of y, add (3 x 4 =) 12 to it, put it in x</p>
<p><tt class="docutils literal">*x = y;</tt> - Here <tt class="docutils literal">*</tt> says to the compiler not to use <tt class="docutils literal">x</tt> itself as the variable rather get the value stored at x, interpret it as an address, put value of y at that address.</p>
</div>
<div class="section" id="arrays">
<h2>Arrays</h2>
<p>Arrays represent adjacent locations in memory that store same type of data objects. E.g. <tt class="docutils literal">int big_array[128];</tt> allocates 512 adjacent bytes in memory.</p>
<div class="highlight"><pre><span class="cm">/* Lets assume that array starts at 0x00ff0000 */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">array_ptr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">big_array</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="n">big_array</span><span class="p">;</span> <span class="cm">/* 0x00ff0000 */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">big_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* 0x00ff0000 */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">big_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* 0x00ff000c (adds 3 * size of int) */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">big_array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="cm">/* 0x00ff000c (adds 3 * size of int) */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="n">big_array</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* 0x00ff000c (adds 3 * size of int) */</span>
<span class="o">*</span><span class="n">array_ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">array_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* 0x00ff000c (but big_array[3] is incremented) */</span>
</pre></div>
<p>The last one is a bit complicated. Lets first see RHS. <tt class="docutils literal">*array_ptr</tt> gets the value pointed to by the pointer <tt class="docutils literal">array_ptr</tt> which is <tt class="docutils literal">big_array[3]</tt> as seen in second-last line. Now in LHS, <tt class="docutils literal">*array_ptr</tt> says to go to the location pointed to by <tt class="docutils literal">array_ptr</tt> which is the address of <tt class="docutils literal">big_array[3]</tt>. So, in effect, it is equivalent to psuedo-code <tt class="docutils literal">big_array[3] = big_array[3] + 1</tt>.</p>
<p><tt class="docutils literal">array_ptr = &amp;big_array[130];</tt> - The array was only 128 element long but we are asking for index 130. But C doesn't give a fuck. It applies the same arithmetic calculation (adding 130 * size of int) and gives back address <tt class="docutils literal">0x00ff0208</tt>. Beware of this!</p>
<p>In general, <tt class="docutils literal">&amp;big_array[i]</tt> is same as <tt class="docutils literal">(big_array + i)</tt>, which implicitly computes <tt class="docutils literal">&amp;big_array[0] + i * <span class="pre">sizeof(big_array[0]);</span></tt></p>
</div>
<div class="section" id="representing-strings">
<h2>Representing strings</h2>
<p>A C-style string is represented by an array of bytes. Elements are one-byte ASCII codes for each character. A 0 byte marks the end of the array.</p>
<p><tt class="docutils literal">char S[4] = &quot;lola&quot;;</tt></p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">show_bytes</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\t</span><span class="s">0x%.2x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">show_int</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">show_bytes</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<p>First argument for <tt class="docutils literal">show_bytes</tt> function is the address of the starting location in memory. It is a pointer pointing to the character (which are of size one byte). Second argument is the length of bytes we want to print. <tt class="docutils literal">%p</tt> is for printing pointer and <tt class="docutils literal">%x</tt> is for printing a value as hex and <tt class="docutils literal">%.2x</tt> is for printing the value as two digit hex.</p>
<p>In <tt class="docutils literal">show_int</tt> function, while passing the first parameter, <tt class="docutils literal">&amp;x</tt> is address of an integer, but by <tt class="docutils literal">(char *) &amp;x</tt>, we are casting it as an address of character.</p>
</div>
<div class="section" id="boolean-algebra">
<h2>Boolean Algebra</h2>
<p>Encode &quot;True&quot; as 1 and &quot;False&quot; as 0.</p>
<ul class="simple">
<li>AND: A&amp;B = 1 when both A is 1 and B is 1</li>
<li>OR: A|B = 1 when either A is 1 or B is 1 or both</li>
<li>XOR: A^B = 1 when either A is 1 or B is 1, but not both</li>
<li>NOT: ~A = 1 when A is 0 and vice-versa</li>
</ul>
<p>DeMorgan's Law: <tt class="docutils literal">~(A|B) = ~A &amp; ~B</tt></p>
</div>
<div class="section" id="bitwise-operations">
<h2>Bitwise Operations</h2>
<p>Bitwise operators <tt class="docutils literal">&amp;</tt>, <tt class="docutils literal">|</tt>, <tt class="docutils literal">^</tt>, <tt class="docutils literal">~</tt> are available in C.
They can be applied to any &quot;integral&quot; data types (long, int, short, char). Operations are applied bitwise.</p>
<p>Examples:</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mh">0x41</span><span class="p">;</span> <span class="cm">/* 0x41 -&gt; 01000001 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>         <span class="cm">/* 10111110 -&gt; 0xBE */</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>    <span class="cm">/* 0x00 -&gt; 00000000 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>         <span class="cm">/* 11111111 -&gt; 0xFF */</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mh">0x69</span><span class="p">;</span> <span class="cm">/* 0x69 -&gt; 01101001 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mh">0x55</span><span class="p">;</span> <span class="cm">/* 0x55 -&gt; 01010101 */</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">;</span>      <span class="cm">/* 01000001 -&gt; 0x41 */</span>
</pre></div>
</div>
<div class="section" id="logic-operations">
<h2>Logic Operations</h2>
<p>Logical operators in C: <tt class="docutils literal">&amp;&amp;</tt>, <tt class="docutils literal">||</tt> and <tt class="docutils literal">!</tt>. <tt class="docutils literal">0</tt> is viewed as false and any non-zero value is treated as true. Early termination occurs where possible.</p>
<p>Examples:</p>
<ul class="simple">
<li><tt class="docutils literal">!0x41</tt>         --&gt; <tt class="docutils literal">0x00</tt></li>
<li><tt class="docutils literal">!0x00</tt>         --&gt; <tt class="docutils literal">0x01</tt></li>
<li><tt class="docutils literal">0x69 &amp;&amp; 0x55</tt>  --&gt; <tt class="docutils literal">0x01</tt></li>
<li><tt class="docutils literal">0x00 &amp;&amp; 0x55</tt>  --&gt; <tt class="docutils literal">0x00</tt></li>
<li><tt class="docutils literal">0x69 || 0x55</tt>  --&gt; <tt class="docutils literal">0x01</tt></li>
<li><tt class="docutils literal">p &amp;&amp; *p++</tt> (avoids null pointer access <tt class="docutils literal">0x00000000</tt>)</li>
</ul>
<p>In the last one, if p is a null pointer (false), then the <cite>and</cite> operation will short-circuit and <tt class="docutils literal">*p++</tt> won't be executed. It is short for <tt class="docutils literal">if (p) { <span class="pre">*p++;</span> }</tt>.</p>
</div>
<div class="section" id="representing-manipulating-sets">
<h2>Representing &amp; Manipulating Sets</h2>
<p>Bit vectors can be used to represent sets.</p>
<p>Width w bit vector represents of {0,...,w-1}</p>
<p>a<sub>j</sub>= 1 if j in A - each bit in the vector represents the absence (0) or presence (1) of an element in the set.</p>
<blockquote>
<p>01101001</p>
<p>76543210</p>
</blockquote>
<p>The set here is {0, 3, 5, 6}.</p>
<blockquote>
<p>01010101</p>
<p>76543210</p>
</blockquote>
<p>And the set here is {0, 2, 4, 6}.</p>
<p>Operations:</p>
<ul class="simple">
<li><tt class="docutils literal">&amp;</tt> Intersections        --&gt; 01000001 {0, 6}</li>
<li><tt class="docutils literal">|</tt> Union                --&gt; 01111101 {0, 2, 3, 4, 5, 6}</li>
<li><tt class="docutils literal">^</tt> Symmetric difference --&gt; 00111100 {2, 3, 4, 5}</li>
<li><tt class="docutils literal">~</tt> Complement           --&gt; 10101010 {1, 3, 5, 7}</li>
</ul>
</div>

    </div>

    

    <div class="entry-tags">
        <a href="/tag/hwswint/">hwswint</a>
    </div>

    
</div></div>
        </div>

        <footer id="footer">
            <hr class="end" />
            
            <p class="copyright">
            <span class="software">
                Powered by <a href="http://lab.lepture.com/liquidluck/">Felix Felicis</a> 3.8,
            </span>
            <span class="theme">
                Theme <a href="https://github.com/lepture/liquidluck-theme-moment" rel="nofollow">moment</a> 1.0 by <a href="http://lepture.com">Hsiaoming Yang</a>
            </span>
            </p>
        </footer>
        <script type="text/javascript" src="/static/mobile.js?v=3b6df"></script>
        
    </body>
</html>