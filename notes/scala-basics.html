<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Scala Basics - Study Notes</title>
        <script>if (top !== self) top.location = self.location;</script>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0" />
        <link rel="stylesheet" href="/static/style.css?v=af9b9" />
        <link rel="stylesheet" href="/static/pygments.css?v=c6adc" />
        
        <link rel="alternate" type="application/rss+xml" href="/feed.xml" title="Study Notes" />
        <!--[if lt IE 9]>
        <script type="text/javascript" src="/static/html5shiv.js?v=9a10c"></script>
        <![endif]-->
        
        
<link rel="canonical" href="/notes/scala-basics.html" />


    </head>
    <body>
        <header id="header">
            <h1 id="brand"><a href="/">Study Notes</a></h1>
            <nav id="nav" role="navigation">
                
                <a href="/"></a>
                <a href="/about.html"></a>
            </nav>
        </header>

        <div id="main">
            <div class="container"><div class="hentry">
    <h1 class="entry-title">Scala Basics</h1>
    <div class="entry-meta">
        <time class="updated" datetime="2013-03-27T00:00:00+05:30" pubdate>
            <a href="/2013/">2013-03-27</a>
        </time>
        <span class="author vcard">
            by <span class="fn">Vivek Agarwal</span>
        </span>
    </div>
    <div class="entry-content">
        <p>Imperative Programming is about</p>

<ul>
<li>modifying mutable variables,</li>
<li>using assignments</li>
<li>and control structures such as if-then-else, loops, breaks, continue, return.</li>
</ul>
<p>Pure imperative programming is limited by the “Von Neumann” bottleneck:</p>

<blockquote>
<p>One tends to conceptualize data structures word-by-word.</p>
</blockquote>
<p>We need other techniques for deﬁning high-level abstractions such as collections, polynomials, geometric shapes, strings, documents.</p>
<p>A theory consists of one or more data types, operation on these data types and laws that describe the relationship between values and operations.</p>
<p>Normally, a theory doesn&#39;t describes mutations!</p>
<p>Functional Programming is about</p>

<ul>
<li>In a restricted sense, it means programming without mutable variables, assignments, loops and other imperative control stuctures.</li>
<li>In a wider sense, functional programming means focusing on the functions to construct elegant programs.</li>
<li>In particular, functions can be values that are produced, consumed and composed.</li>
<li>Functions are first class citizens. They can be defined anywhere, including inside other functions.</li>
<li>Functions like any other value, passed as parameter to functions and returned as results. As for other values, there exists a set operators to compose
functions.</li>
</ul>
<p>Functional Programming is becoming increasingly popular because it oﬀers an attractive method for exploiting parallelism for multicore and cloud computing.</p>
<p>In a parallel environment, when multiple threads try to access and mutate a shared mutable state, problems arises. Though there are ways to solve it, it is not always easy and elegant as desired. In functional programming, by eliminating the use of mutable states these problems can be easily solved.</p>
<p>Functions can be defined as:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="k">def</span> <span class="n">sumOfSquares</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">square</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>

<span class="cm">/* Here, the return type is defined as well. */</span>
<span class="k">def</span> <span class="n">power</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
<p><strong>Call by value (CBV)</strong> - All the arguments are evaluated to a simple value and then passed on to the function body as soon as the function is ran.</p>
<p>Example:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">example</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">example</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm">Evaluated as-</span>
<span class="cm">example(2+3, 7) -&gt; example(5, 7) -&gt; 5 * 5 -&gt; 25</span>
<span class="cm">*/</span>
</pre></div>
<p><strong>Call by name (CBN)</strong> - All the arguments are passed to the function body as it is and evaluation is done by the code within the function body.</p>
<p>Example:</p>
<div class="highlight"><pre><span class="n">example</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm"> * Evaluated as-</span>
<span class="cm"> * example(2+3, 7) -&gt; (2+3) * (2+3) -&gt; 5 * (2+3) -&gt; 5 * 5 -&gt; 25</span>
<span class="cm"> */</span>
</pre></div>
<p>If CBV evaluation of an expression <em>e</em> terminates, then CBN evaluation of <em>e</em> terminates too.</p>
<p>The other direction is not true.</p>
<p>Non-termination example</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">first</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>

<span class="n">first</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">loop</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm"> * Here, the loop resolves to itself infinitely.</span>
<span class="cm"> * </span>
<span class="cm"> * Under CBN:</span>
<span class="cm"> * first(1, loop) -&gt; 1</span>
<span class="cm"> * </span>
<span class="cm"> * Under CBV:</span>
<span class="cm"> * first(1, loop) -&gt; first(1, loop) -&gt; first(1, loop)....</span>
<span class="cm"> */</span>
</pre></div>
<p>Scala normally uses call-by-value.</p>
<p>But if the type of a function parameter starts with =&gt;, it uses call-by-name.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">consOne</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>

<span class="cm">/* Here, x is evaluated as CBV by default and y is evaluated as CBN which we explicitly forced it to. */</span>
</pre></div>
<p><strong>Conditional Expressions</strong></p>
<p>if-else in Scala is used for expressions, not statements.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span>
</pre></div>
<p>Rewrite rules for Booleans (e is an arbitrary expression):</p>
<div class="highlight"><pre><span class="cm">/* !true        --&gt; false</span>
<span class="cm"> * !false       --&gt; true</span>
<span class="cm"> * true &amp;&amp; e    --&gt; e</span>
<span class="cm"> * false &amp;&amp; e   --&gt; false</span>
<span class="cm"> * true || e    --&gt; true</span>
<span class="cm"> * false || e   --&gt; e</span>
<span class="cm"> */</span>
</pre></div>
<p><strong>Value Definitions</strong></p>
<p>The <code>def</code> form is &ldquo;by name&rdquo;, its right hand side evaluated on each use.</p>
<p>There is also a <code>val</code> for, which is &ldquo;by value&rdquo;. Example-</p>
<div class="highlight"><pre><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div>
<p>The right hand side of a val definition is evaluated at the point of the definition itself.</p>
<p>Afterwards the name refers to the value. Here y refers to 4, not square(2).</p>
<p><strong>Difference between val and def</strong></p>
<p>The difference becomes apparent when the right hand side does not terminate.</p>
<div class="highlight"><pre><span class="cm">/* This works fine. */</span>
<span class="k">def</span> <span class="n">loop</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">loop</span>
<span class="k">def</span> <span class="n">x</span> <span class="k">=</span> <span class="n">loop</span>

<span class="cm">/* However, this will get stuck in an infinite loop since the interpreter tries to evaluate the loop right at the point of definition. */</span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">loop</span>
</pre></div>
<p>&amp;&amp; and || implementation as functions-</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">and</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">false</span>
<span class="k">def</span> <span class="n">or</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(!</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">true</span>
</pre></div>
<p><strong>Return type is required when calling a function recursively.</strong></p>
<p><strong>Blocks in Scala</strong></p>
<p>A block is defined by curly braces {&hellip;.}.</p>
<div class="highlight"><pre><span class="o">{</span>
    <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span>
</pre></div>
<p>It constains a sequence of definition or expressions.
The last element of a block is an expression that deﬁnes its value.
This return expression can be preceded by auxiliary deﬁnitions.
Blocks are themselves expressions; a block may appear everywhere an expression can.</p>

<ul>
<li>The deﬁnitions inside a block are only visible from within the block.</li>
<li>The deﬁnitions inside a block shadow deﬁnitions of the same names outside the block.</li>
</ul>
<p><strong>Semicolons</strong></p>
<p>In Scala, semicolons at the end of a line is optional in most cases. If there are more than one statements in one line, then they need to be separatd with a semi-colon.</p>
<p><strong>Semicolons and inﬁx operators</strong></p>
<p>One issue with Scala’s semicolon convention is how to write expressions that span several lines. For instance-</p>
<div class="highlight"><pre><span class="n">someLongExpression</span>
<span class="o">+</span> <span class="n">someOtherExpression</span>

<span class="cm">/* would be interpreted as */</span>

<span class="n">someLongExpression</span><span class="o">;</span>
<span class="o">+</span> <span class="n">someOtherExpression</span>
</pre></div>
<p>Two ways to overcome the problem.</p>
<div class="highlight"><pre><span class="cm">/* Multiline expression can be written inside parentheses. */</span>
<span class="o">(</span><span class="n">someLongExpression</span>
    <span class="o">+</span> <span class="n">someOtherExpression</span><span class="o">)</span>

<span class="cm">/* Or operator can be written on the first line because this tells the Scala compiler that the expression is not yet finished. */</span>
<span class="n">someLongExpression</span> <span class="o">+</span>
<span class="n">someOtherExpression</span>
</pre></div>
<p><strong>Tail Recursion</strong></p>
<p>If a function calls itself as its last action, the function&#39;s stack frame can be reused. This is called tail recursion. Tail recursive functions are iterative processes.</p>
<p>In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be suﬃcient for both functions. Such calls are called tail-calls.</p>
<p>Example of non-tail recursive factorial function:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
<p>Example of tail recursive factorial function:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> 
    <span class="k">def</span> <span class="n">fac_loop</span><span class="o">(</span><span class="n">accum</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">accum</span>
        <span class="k">else</span> <span class="n">fac_loop</span><span class="o">(</span><span class="n">accum</span> <span class="o">*</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">loop</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
<p>In the first example, the return value <code>x * factorial(x-1)</code> has a pending calculation of x multiplied by factorial of (x-1) which would have to wait until that factorial has been computed and thus that recursive chain keeps on growing.</p>
<p>However, in the second example, for the return value <code>fac_loop(accum * n, n - 1)</code> the function calls itself and there are no pending computation to be done, so the further function calls can take place in the same stack frame without growing like crazy like in the previous example.</p>

    </div>

    

    <div class="entry-tags">
        <a href="/tag/scala/">scala</a><a href="/tag/basics/">basics</a>
    </div>

    
</div></div>
        </div>

        <footer id="footer">
            <hr class="end" />
            
            <p class="copyright">
            <span class="software">
                Powered by <a href="http://lab.lepture.com/liquidluck/">Felix Felicis</a> 3.8,
            </span>
            <span class="theme">
                Theme <a href="https://github.com/lepture/liquidluck-theme-moment" rel="nofollow">moment</a> 1.0 by <a href="http://lepture.com">Hsiaoming Yang</a>
            </span>
            </p>
        </footer>
        <script type="text/javascript" src="/static/mobile.js?v=3b6df"></script>
        
    </body>
</html>